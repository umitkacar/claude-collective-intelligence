# Logstash Filter Configuration
# Processes, enriches, and transforms logs

filter {
  # ============ PARSING & NORMALIZATION ============

  # Parse JSON logs if not already parsed
  if [type] == "syslog" {
    grok {
      match => {
        "message" => "%{SYSLOGLINE}"
      }
      tag_on_failure => ["grok_syslog_failure"]
    }
  }

  # Parse application-specific formats
  if [message] =~ /^\d{4}-\d{2}-\d{2}/ {
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{DATA:level}\] \[%{DATA:service}\] %{GREEDYDATA:message}"
      }
      tag_on_failure => ["grok_app_failure"]
    }
  }

  # ============ FIELD STANDARDIZATION ============

  # Ensure standard field names
  mutate {
    # Rename common variations
    rename => {
      "severity" => "level"
      "severity_label" => "level"
      "msg" => "message"
      "log_message" => "message"
      "trace_id" => "trace_id"
      "traceId" => "trace_id"
      "span_id" => "span_id"
      "spanId" => "span_id"
      "request_id" => "request_id"
      "requestId" => "request_id"
      "correlation_id" => "correlation_id"
      "correlationId" => "correlation_id"
    }

    # Ensure standard field presence
    add_field => {
      "[@metadata][timestamp]" => "%{@timestamp}"
      "[@metadata][index]" => "logs-%{[service]}-%{[environment]}-%{+YYYY.MM.dd}"
    }

    # Lowercase sensitive field values
    lowercase => ["level"]
  }

  # ============ TRACE CONTEXT INJECTION ============

  # Extract trace context if present in message
  if [message] =~ /traceId|trace_id/ {
    grok {
      match => {
        "message" => "traceId[=:]?%{DATA:trace_id:json}"
      }
      tag_on_failure => ["trace_extraction_failed"]
    }
  }

  # Extract span context
  if [message] =~ /spanId|span_id/ {
    grok {
      match => {
        "message" => "spanId[=:]?%{DATA:span_id:json}"
      }
      tag_on_failure => ["span_extraction_failed"]
    }
  }

  # ============ FIELD EXTRACTION ============

  # Extract HTTP information
  if [message] =~ /HTTP\// {
    grok {
      match => {
        "message" => "%{IP:client_ip}.*\"%{WORD:http_method} %{DATA:http_uri} HTTP/%{NUMBER:http_version}\" %{NUMBER:http_status} %{NUMBER:http_response_size:int}"
      }
      tag_on_failure => ["http_grok_failure"]
    }

    # Extract timing information
    if [message] =~ /duration/ {
      grok {
        match => {
          "message" => "duration[=:]?%{NUMBER:duration_ms:float}"
        }
      }
    }
  }

  # Extract error stack traces
  if [level] == "error" {
    multiline {
      pattern => "^\s"
      what => "previous"
      stream_identity => "%{host}-%{message}"
    }
  }

  # ============ ENRICHMENT ============

  # GeoIP Enrichment
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
      fields => ["country_code2", "country_name", "city_name", "latitude", "longitude", "location"]
      tag_on_failure => ["geoip_lookup_failure"]
    }
  }

  # User Agent Parsing
  if [user_agent] {
    useragent {
      source => "user_agent"
      target => "user_agent_parsed"
    }
  }

  # Environment mapping
  if ![environment] {
    translate {
      field => "hostname"
      destination => "environment"
      dictionary => {
        "prod-server" => "production"
        "staging-server" => "staging"
        "dev-server" => "development"
      }
      fallback => "unknown"
      refresh_interval => 300
    }
  }

  # Service mapping
  if ![service] {
    translate {
      field => "logger_name"
      destination => "service"
      dictionary => {
        "ai-agent-platform" => "ai-agent-platform"
        "rabbitmq-processor" => "rabbitmq-processor"
        "api-gateway" => "api-gateway"
        "database-service" => "database-service"
      }
      fallback => "unknown-service"
    }
  }

  # ============ CLASSIFICATION & CATEGORIZATION ============

  # Error categorization
  if [level] == "error" {
    mutate {
      add_field => {
        "error_category" => "application_error"
      }
    }

    if [message] =~ /timeout|deadline/i {
      mutate {
        update => {
          "error_category" => "timeout_error"
        }
      }
    }

    if [message] =~ /permission|unauthorized|forbidden/i {
      mutate {
        update => {
          "error_category" => "security_error"
        }
      }
    }

    if [message] =~ /database|connection|sql/i {
      mutate {
        update => {
          "error_category" => "database_error"
        }
      }
    }

    if [message] =~ /memory|heap|OOM/i {
      mutate {
        update => {
          "error_category" => "resource_error"
        }
      }
    }
  }

  # ============ FIELD TYPING ============

  mutate {
    convert => {
      "duration_ms" => "float"
      "http_status" => "integer"
      "http_response_size" => "integer"
      "user_id" => "string"
      "request_id" => "string"
      "trace_id" => "string"
      "span_id" => "string"
    }
  }

  # ============ CORRELATION ============

  # Ensure trace ID consistency
  if ![trace_id] and [request_id] {
    mutate {
      add_field => {
        "trace_id" => "%{request_id}"
      }
    }
  }

  # Add correlation fields if missing
  if ![correlation_id] {
    mutate {
      add_field => {
        "correlation_id" => "%{request_id:-%{trace_id:-%{[@timestamp]}}}"
      }
    }
  }

  # ============ DROP UNNECESSARY LOGS ============

  # Example: Drop health check logs
  if [http_uri] =~ /\/health|\/healthz|\/ping|\/status/ {
    # Optional: uncomment to drop health checks
    # drop {}
  }

  # Drop logs with empty messages
  if ![message] or [message] == "" {
    drop {}
  }

  # ============ CLEANUP ============

  # Remove unnecessary fields to reduce index size
  mutate {
    remove_field => [
      "[@metadata][beat]",
      "[@metadata][type]",
      "[@metadata][version]",
      "[input][type]",
      "[agent][type]",
      "[agent][version]"
    ]

    remove_tag => [
      "beats_input_codec_json_applied"
    ]
  }

  # ============ FINAL PROCESSING ============

  # Ensure timestamp is properly set
  if ![timestamp] {
    mutate {
      add_field => {
        "timestamp" => "%{@timestamp}"
      }
    }
  }

  # Add processing metadata
  mutate {
    add_field => {
      "[@metadata][processed_at]" => "%{@timestamp}"
      "[@metadata][logstash_version]" => "8.11.0"
    }
  }
}
